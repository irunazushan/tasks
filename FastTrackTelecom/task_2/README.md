# Задачи третьей недели

## Задание 1

На этой неделе в качестве домашнего задания необходимо решить 2 задачи. 
Задание 1 (15 баллов): на основании кода с вебинара 
1. Дополнить решение токенами: max, sqr
2. Добавить все необходимые классы в определение Token
3. Реализовать ParseName, который читает последовательность букв и возвращает токен соответствующей функции или UnknownToken
4. Закончить Tokenize

# Решение:
1. Добавил unordered_map kName2Token для прочтения строковых токенов "sqr", "max", "min", "abs"
2. Создал функцию ParseName который возвращает Token, по символьно считывает строку, пока символ является буквой, все сохраняет в nameTok - таким образом создается строка, если nameTok пустая, то значит символ не содержал букву и поэтому мы его вручную добавляем в nameTok и уеличиваем позиицю. Далее в kName2Token ищем токен с именем nameTok, если нет, то возвращаем UnknownToken.
3. В Tokenize добвил tokens.emplace_back(ParseName(input, pos)), который добавляет в вектор наш строковой токен, далее переходим к следующей позиции.      


## Задание 2
Напишите библиотеку, реализующую шаблонный класс для односвязного списка с поддержкой операций вставки, удаления и поиска заданного элемента.

# Решение:
1. Создал класс LinkedList, объявил начало листа head и конец tail(nullptr)
2. Реализовал Node, хранящий значение и ссылку на следующий узел
3. Создал следующие конструкторы для листа: пустой, с массивом данных на основе initializer_list, перемещения, копирования
4.Внутри класса создал класс итератора: LinkedListIterator, для перемещения по списку используем префиксный инкремент operator++()
5.Для вставки был создан 
    - insert_after - вставляет элемент после текущего. Текущий будет ссылаться на вставленный элемент, а вставленный будет ссылаться на тот элемент, который ссылался текущий.
    - push_front - вставляет элемент в начало списка по той же логике что и insert_after, только текущим элементов всегда будет head
6. Удаление заданного элемента:
    - erase_after -  удаляет следующий элемент после текущего итератора
    - erase - проходится по всему листу с помощью итератора cur в цикле while, если находит нужное значение, то удаляет cur c помощью erase_after(prevCur), где prevCur - итератор, который отстаёт от cur на одну итерацию.
    - pop_front - удаляет первый элемент списка.
7. Поиск элемента:
    - find  - возвращает итератор на нужный элемент. Поиск осуществялется прохождением всего листа в цилке, цикл идет пока итератор не дойдет до конца листа или не найдет нужное значение. Если элемент не найдет, то возвращается итератор на начало листа